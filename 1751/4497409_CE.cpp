#include <iostream>#include <math.h>#include <algorithm>using namespace std;const int N = 850;struct TOWNS{ int x, y;}town[N];struct EDGE{ int i, j, k;}a[N*N];int la, n;void read(){ int i, j, k; cin>>n; for(i=1; i<=n; i++)  cin>>town[i].x>>town[i].y; for(i=1; i<=n; i++)  for(j=i+1; j<=n; j++)  {   a[la].i = i;   a[la].j = j;   a[la].k = (town[i].x - town[j].x ) * (town[i].x - town[j].x) + (town[i].y - town[j].y) * (town[i].y - town[j].y);   la ++;  } cin>>k; while( k-- ) {  cin>>i>>j;  a[la].i = i;  a[la].j = j;  a[la].k = 0;  la ++; }}int father[N], rank[N];inline void makeset( int x ) // 初始化{ rank[x] = 0; father[x] = x;}int find( int x ) //寻找祖先{ int px = x, i; while( px != father[px]) px = father[px]; while( x != px) {  i = father[x];  father[x] = px;  x = i; } return px;}void unionset(int x, int y) // 合并 { x = find(x); y = find(y); if( rank[x] > rank[y] ) father[y]  = x; else {  father[x] = y;  if( rank[x] == rank[y]) rank[y]++; }}bool cmp(EDGE X, EDGE Y){ return X.k < Y.k;}void kruskal(){ int i, x, y; sort(a, a + la, cmp); for(i=1; i<=n; i++) makeset(i);  n--; for(i=0; n && i<la; i++) {  x = find( a[i].i );  y = find( a[i].j );  if( x != y )  {   unionset(x, y);   if( a[i].k ) cout<<a[i].i<<' '<<a[i].j<<endl;   n--;  } }}int main(){ read(); kruskal();}
